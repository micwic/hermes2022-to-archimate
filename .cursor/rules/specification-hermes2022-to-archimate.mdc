---
description: Spécification générale du projet hermes2022-to-archimate
alwaysApply: true
---

# hermes2022-to-archimate/.cursor/rules/specification-hermes2022-to-archimate.mdc: Spécification générale du projet hermes2022-to-archimate

> Créé le : 2025-08-15  
> Dernière mise à jour : 2025-10-20

## Description générale

- Le projet hermes2022-to-archimate vise à créer une brique logicielle qui participe à l'objectif de constituer un référentiel d'architecture d'entreprise unique qui comprend à la fois les méthodologies de projet - en l'occurrence HERMES2022 édictée par la Confédération Helvétique - et les éléments d'architecture d'entreprise (selon les couches du framework Archimate 3.2 : Stratégie, Métier, Application, Technologie, Implémentation & Migration et Migration et l'analyse transverse Motivation) impactés par les projets de transformation digitale.

- La brique logicielle est appelée à traduire les concepts HERMES2022 en éléments et relations standards de référence conformes à Archimate de manière à permettre de les décliner ensuite dans des éléments spécialisés sous-jacents spécifiques aux projets respectifs dans lesquels la méthode est appliquée. Ces derniers étant liés aux éléments standards par une relation de Spécialisation pour assurer le lien avec les standards de la méthodologie.

  | Concept HERMES2022    | Traduction en Archimate 3.2 |
  |-----------------------|-----------------------------|
  | Scénarios            | Fonctions métier qui regroupe des modules |
  | Modules              | Fonctions métier qui regroupe des processus métier |
  | Phases               | Processus métier qui regroupe des tâches |
  | Tâches               | Processus (élémentaire) métier qui implique (assignation selon raci) des rôles et qui produit (trigger événements, lecture/écriture données métier) des résultats |
  | Rôles                | Rôles métier assigné à une tâche ou associé une collaboration métier (représentant un comité) |
  | Résultats (jalons)   | Evénements métier |
  | Résultats (artefacts)| Données métier -> Artefacts |

- Le concept est appelé à servir de repère méthodologique de manière totalement intégré au référentiel d'entreprise qui comprend dès lors la démarche standard de référence et la démarche effectivement appliquée aussi bien que les éléments impactés par la démarche de projet de transformation digitale constituant une source unique de vérité (selon d'autres normes standards également) à même d'alimenter des fonctionnalités Retrieval Augmented Generation destinées à des modèles de langage large (LLM) par exemple avec le projet cii-via-cip-archimate-ia-repository. Le concept est étendu en cours d'exécution du projet après avoir été alimenté avec la méthodologie standard d'une part avec les éléments spécifiques mis en oeuvre dans la démarche projet dans le contexte et également d'autre part avec les éventuelles applications qui supportent les tâches (relation de service), voire produisent des artefacts (données applicatives intermédiaires entre artefacts et données métier).

  | Couche | Description                                      | Éléments Clés                                                                 |
  |--------|--------------------------------------------------|-------------------------------------------------------------------------------|
  | 1      | Méthodologie standard (Référence/Repère méthodologique) | - Eléments (Processus métier, données métier, artefacts (modèles de document), rôles, collaborations métier (instances)                                     |
  | 2      | Démarche appliquée au projet                     | - Extensions ajoutées en cours d'exécution avec des éléments de mêmes type que ceux de la méthodologie standard effectivement mis en oeuvre, reliés au standard avec une relation de spécialisation                                             |
  | 3      | Extensions potentielles (Moyens au service du projet)                          | - Applications mises en œuvre (gestion, bureautique, modélisation, dev, ...)<br>- Artefacts produits dans le cadre de la démarche de projet<br>- Localisation/Emplacement des artefacts (node, device)                              |
  | 4      | Éléments de l'architecture impactés                                | - Infrastructure (Sites)<br>- Systèmes & Réseaux<br>- Applications & Données métier<br>- Organisation et Chaîne de valeur Métier<br>- Motivation & stratégie |

- La finalité des différents projets menés dans le cadre de cette initiative personnelle est de faire la démonstration de la pertinence de combiner Archimate avec l'intelligence artificielle pour en faire un référentiel source unique de vérité bâti selon des métamodèles standards qui peut se décliner sur l'entier du cycle de vie d'un produit logiciel de l'élaboration de la vision métier jusqu'à la documentation technique de référence de bas niveau et qui soit interprétable par l'IA de manière sûre et fiable pour produire des artefacts sous diverses autres formes à but et destination d'audiences spécifiques (audit par exemple, conformité à des standards, ...).

## Contexte

- HERMES2022 est la méthodologie standard de gestion de programme et de projet de la confédération helvétique (<https://www.hermes.admin.ch/fr/>)
- Archimate est une norme de représentation d'architecture d'entreprise édictée par l'Open Group, la version actuelle est la version 3.2 (<https://pubs.opengroup.org/architecture/archimate3-doc>)
- Archi est un outil de gestion et de modélisation d'un référentiel d'architecture d'entreprise selon la norme Archimate (<https://www.archimatetool.com>), il comprend un plugin JArchi qui permet de manipuler programmatiquement les modèles ainsi que les éléments, les relations et les vues d'un modèle.
- Cursor est un outil de développement centré sur l'usage de l'IA.
- NuExtract (3.8B, basé sur Phi-3-mini) est un llm open source conçu expressément pour extraire des données structurées depuis du texte ou HTML vers JSON (<https://www.numind.ai>). Développé par NuMind, le modèle garantit un JSON valide systématiquement et excelle dans le respect des schémas.
- Ollama est un outil open source pour servir des modèles de langage locaux de manière simple et efficace (<https://www.ollama.com>), permettant le déploiement et l'exécution de LLM comme NuExtract directement sur du hardware personnel (ex. RTX 1000 Ada). Il fournit une API compatible OpenAI pour une intégration aisée avec des applications TypeScript, facilitant l'extraction structurée HTML→JSON en environnement souverain et hors ligne, tout en optimisant l'utilisation des ressources GPU.
- Javascript/Typescript sont les langages de scripting privilégiés dans le cadre du projet.
- Le cycle de développement logiciel priviliégie Behavior-driven Development, avec Gherkin et les framerwork cucumber et Jest (voir @bdd-governance.mdc)
- Neo4j est une base de données graphe avec des fonctionnalités additionnelles RAG et Vector utilisées pour alimenter l'IA avec des composants client-serveur MCP selon les principes RAG intégrées au chat Cursor. Une base documentaire vectorisée est créée dans neo4j à partir des modèles Archimate exporté de Archi pour alimenter l'IA dans le cadre du projet cii-via-cip-archimate-ia-repository.
- Customer Information Interface via Customer Information Port est un projet personnel d'étude d'opportunité mené selon HERMES2022 et Archimate et donnant lieu à l'élaboration d'une preuve de concept complexe nécessitant plusieurs projets de développements spécifiques (React, Spring, Flowable, UIPath, Kexcloack, OsixiaLDAP, OAuth2, ...) dans un contexte sécurisé d'entreprise qui vérifie la faisabilité technique et fournit des indicateurs clés pour mesurer l'effort nécessaire d'une réalisation à l'échelle.

## Objectifs

- Acquérir à partir d'internet, faire traduire et mettre à jour de manière efficiente et sûre les concepts de la méthode HERMES2022 en éléments et relations selon Archimate à l'aide de l'IA (modèle LLM spécialisé NuExtract) dans un référentiel d'architecture d'entprise selon Archimate géré avec Archi. Ces éléments et relations de référence à la méthodologie standard peuvent ainsi être utilisés dans le cadre des projets avec des éléments spécialisés de même type selon l'application de la méthode dans les contexte des projects planifiés et exécutés.

- Alimenter un pipeline RAG à base MCP avec ces mêmes informations de référence de la méthodolgie standard chargées dans Neo4j aux côtés des éléments du référentiel d'architecture d'entpreprise. Le modèle IA généraliste utilisé pour générer des réponses à partir du référentiel d'architecture d'entreprise peut ainsi être alimenté en information sûre et fiable sur la méthodologie standard appliquée même si il n'a pas été entraîné sur le sujet.

- Proposer une alternative à l'architecture ETL d'import/export à partir du format d'interchange standard défini par l'Open Group utilisée dans le cadre du projet cii-via-cip-archimate-ia-repository en utilisant plutôt l'interface du plugin JArchi de Archi pour manipuler le référentiel d'architecture d'entreprise sous Archi de manière interactive.

## Conception générale

- Le projet est divisé en deux modules distincts :
  - **Script Javascript JArchi**
    - 1a) Extraction/Transformation des concepts HERMES2022 à partir du site internet
    - 1b) Chargement/Mise à jour des éléments et relations correspondant aux concepts HERMES2022 dans un modèle Archimate de Archi
  - **Javascript**
    - 2) Chargement/Mise à jour des noeuds d'une base de données graphe Neo4j correspondant aux concepts standards HERMES2022.

- L'Extraction/Transformation donne lieu à la création/mise à jour de fichiers intermédiaires structurés et vérifiables pour être partagés comme données de référence en entrée par les autres modules 1) pour le chargement initial et la mise à jour de modèles Archimate Archi 2) et pour le chargement des concepts HERMES2022 dans la base de données graphe Neo4j.

- Les fichiers intermédiaires sont structurés selon un standard reconnu, lisibles et vérifiables tant par l'humain que par la machine (process flow with humanin the loop).

## Structure de répertoire

| Élément | Type | Description |
|:--------|:-----|:------------|
| `/hermes2022-concepts-site-extraction/` | Répertoire | Module d'extraction des concepts HERMES2022 à partir du site internet |
| `/archimate-model-loader/` | Répertoire | Chargement initial ou mis à jour dans un modèle Archimate des éléments et relations correspondant aux concepts HERMES2022 |
| `/hermes2022-ia-loader` | Répertoire | Chargement des concepts HERMES2022 dans Neo4j |
| `/shared/` | Répertoire | Structure, types, validations et données partagées entre les modules |
| `/__tests__/` | Répertoire | Tests de conformité à la présente spécification |
| `README.md` | Documentation | [Lien sur la documentation selon les règles de gouvernance générale] |

## Décisions architecturales et techniques

### Approche hybride IA & scripting

#### Description détaillée de la décision

2025-08-16 Plusieurs approches ont été envisagées pour extraire les concepts HERMES2022 du site internet de la Confédération Helvétique (<https://www.hermes.admin.ch/en/>).
L'analyse des contenus du site en question a permis d'identifier des pages spécifiques parfaitement organisées qui contiennent les informations nécessaires. Elles peuvent être interprétées efficacement et sûrement par l'IA avec des prompts appropriés pour produire des listes intermédiaires structurées sur lesquelles se reposer pour alimenter et mettre à jour un référentiel Archimate. Lesdites listes intermédiaires peuvent par ailleurs être administrées manuellement le cas échéant pour procéder à des ajustements et/ou à des corrections.

Le projet est ainsi divisé en deux parties qui se déroulent séquentiellement et trois modules :

**Phase 1 - Extraction :**

- `hermes2022-concepts-site-extraction` : Extraction automatisée des concepts HERMES2022 depuis le site web avec assistance IA, production de fichiers JSON intermédiaires validés

**Phase 2 - Chargement parallèle :**

- `archimate-model-loader` : Chargement des concepts dans un modèle ArchiMate via l'interface JArchi d'Archi
- `hermes2022-ia-loader` : Chargement des concepts dans Neo4j pour services RAG et intégration IA

**Architecture modulaire :**

- Modules indépendants communiquant via fichiers JSON intermédiaires
- Interface standardisée JSON Schema pour validation des données
- Exécution séquentielle Phase 1 puis Phase 2, modules Phase 2 exécutables en parallèle

#### Justification de la décision

- Utilisation et mise en valeur du potentiel de l'IA dans un contexte parfaitement approprié
- Solution sûre avec revue et validation possible des listes intermédiaires produites
- Gain de temps et d'effort substantiel

#### Patterns validés à suivre suite à la décision

- **Séparation extraction/chargement** : Modules indépendants avec interfaces définies
- **Validation humaine** : Processus de revue des listes intermédiaires
- **IA assistée** : Prompts structurés pour extraction cohérente

#### Anti-Patterns en raison d'erreurs identifiées, à ne pas reproduire

- **Extraction directe** : Éviter l'extraction directe sans validation → **Solution** : Listes intermédiaires validables → **Règle à adopter** : Processus de validation systématique

#### État d'implémentation de la décision

🚧 [En cours de conception et réalisation]

### Structure et format du fichier intermédiaire

#### Description détaillée pour Structure et format du fichier intermédiaire

- Le fichier intermédiaire est en format JSON
- La structure est définie et les données sont typées sont un schéma json (jsonschema)
- Les définitions du schéma json sont gérées dans plusieurs fichiers représentant les différentes parties du fichier (#ref, #ref) pour faciliter la maintenance
- Un fichier de données unique est créé afin de faciliter l'interprétation et le chargement de celui-ci dans la base de données graphe Neo4j pour alimenter l'IA par RAG

#### Justification pour Structure et format du fichier intermédiaire

- Format JSON : Lisibilité humaine et machine
- JSON Schema : Validation structurelle automatisée
- Modularité : Maintenance facilitée par la séparation des schémas
- Interopérabilité : Format universel pour les 3 modules

#### Patterns validés pour Structure et format du fichier intermédiaire

- **JSON Schema modulaire** : Séparation par domaines fonctionnels
- **Validation systématique** : Contrôles automatisés avant consommation
- **Documentation intégrée** : Schémas auto-documentés

#### Anti-Patterns pour Structure et format du fichier intermédiaire à éviter

- **Schéma monolithique** : Éviter un seul fichier schema complexe → **Solution** : Modularité par références → **Règle à adopter** : Un schéma par domaine ou concept pour faciliter la maintenance

#### État d'implémentation pour Structure et format du fichier intermédiaire

🚧 [En cours de conception et réalisation]

### Cadre de tests BDD et validation JSON — frameworks, versions, usages

#### Description détaillée pour Cadre de tests BDD et validation JSON

- Frameworks et versions actuellement utilisés au stade tests:
  - Jest: 30.0.5
  - jest-cucumber: 4.5.0
  - ts-jest: 29.4.1
  - babel-jest: 30.0.5
  - Ajv: 8.17.1
  - ajv-formats: 3.0.1
- Portée: exécution des scénarios BDD (Gherkin) et validation des artefacts
  JSON intermédiaires via JSON Schema.
- Contexte Node.js: à documenter (version exacte de l’environnement d’exécution).

#### Critères de choix des versions

- Compatibilité Node LTS (≥18; recommandé: 20).
- Alignement inter-packages (mêmes majors, intégrations éprouvées).
- Stabilité/maintenance et correctifs récents.
- Simplicité d’exécution des steps TypeScript sans build.

#### Justification des version par composant

##### Jest 30.0.5**

- Version majeure actuelle, maintenance active, corrections/performances récentes.
- Aligne babel-jest sur la même major 30.
- Compatible Node 18/20; pas de besoin d’écosystème Cucumber séparé.

##### jest-cucumber 4.5.0

- Couche BDD Gherkin fine au‑dessus de Jest; découplée du moteur TS.
- Version récente stable, compatible Jest 29/30.

##### ts-jest 29.4.1

- Permet d’exécuter directement des steps .ts sans transpilation préalable.
- Choix pragmatique tant que la compatibilité avec Jest 30 est satisfaisante dans ce repo. Si contrainte, on bascule soit:
à Jest 29.x (compat matrice officielle avec ts-jest 29.x), soit
à une chaîne Babel‑only (supprimer ts-jest, compiler via babel-jest + preset TS).

##### babel-jest 30.0.5

- Major alignée avec Jest 30; nécessaire pour transformer d’éventuels fichiers JS/ESM et alternative de repli pour TS si on quitte ts-jest.

##### Ajv 8.17.1 + ajv-formats 3.0.1

- Derniers mineurs du major 8; ajv-formats v3 est la branche prévue pour Ajv v8.
- Validation JSON Schema robuste, stricte et performante.

#### Justification pour Cadre de tests BDD et validation JSON

- jest-cucumber: BDD lisible (Gherkin) avec une exécution unifiée via Jest.
- ts-jest: exécution directe des steps TypeScript sans build préalable.
- Ajv (+ formats): validation stricte et traçable des artefacts JSON selon
  les schémas partagés (contrat d’interface).

#### Patterns validés à suivre pour Cadre de tests BDD et validation JSON

- Configuration centralisée: `cursor-ws-hermes2022-to-archimate/cucumber-jest.config.js`.
- Découverte des steps: `**/__tests__/{integration,e2e}/**/*.steps.{js,ts}` ;
  environnement `node` ; setup: `__tests__/support/jest-cucumber-setup.js`.
- Résolution des artefacts: répertoire piloté par `artifactBaseDir` dans
  `hermes2022-concepts-site-extraction/config/extraction-config.json` avec
  override optionnel par `HERMES2022_CONCEPTS_ARTIFACT_DIR`.
- Sidecar d’approbation: fichier `*.approval.json` adjacent à l’artefact.
- Schémas de référence: `shared/hermes2022-extraction-files/config/json-schemas/*.json`.
- Outils éditeur: configuration VSCode Cucumber (Gherkin) dans
  `cursor-ws-hermes2022-to-archimate/cucumber-vscode-plugin-settings.json`.

#### Anti-Patterns en raison d'erreurs identifiées, à ne pas reproduire pour Cadre de tests BDD et validation JSON

- Runner Cucumber séparé: éviter la duplication d’infrastructure de test ;
  privilégier Jest unique.
- Recherche multi-emplacements implicite pour les artefacts: éviter des
  fallbacks opaques ; privilégier la configuration explicite du répertoire.
- Couplage dur aux chemins: éviter les chemins codés en dur dans les steps ;
  utiliser config + variables d’environnement.

#### État d'implémentation de Cadre de tests BDD et validation JSON

✅ Fonctionnel pour le module `hermes2022-concepts-site-extraction` (tests BDD
et validations JSON). Montées de version à effectuer de manière coordonnée
(Jest/ts-jest) si nécessaire.

### Gestionnaire de paquets — npm (interdiction de mixer avec yarn)

#### Description détaillée

- Gestionnaire retenu pour ce projet: npm.
- Contexte: d’autres projets imposent yarn (ex. intégrations Flowable/React), mais ce dépôt utilise npm depuis l’origine (installation des dépendances, exécution des tests).

#### Justification

- Cohérence et traçabilité: éviter les dérives de lockfiles et résolutions différentes.
- Simplicité: outillage homogène (`npm install`, `npx jest`, scripts npm).
- Isolation des projets: chaque dépôt fixe explicitement son gestionnaire.

#### Patterns validés

- Installation: `npm install` exclusivement.
- Exécution: `npx jest …` ou via scripts npm (`npm run test` si défini).
- Pas de lockfile yarn: pas de `yarn.lock` dans ce repo.

#### Anti-Patterns à éviter

- Mélange npm/yarn dans le même dépôt.
- Utilisation de `yarn` ou `pnpm` pour ce projet.

#### État d’implémentation

✅ npm utilisé pour l’installation et l’exécution (`npx jest …`); aucun artefact yarn attendu.

### Gestion des dépendances inter-modules : Chemins explicites relatifs à repoRoot

#### Description détaillée

- [2025-10-20] Les dépendances vers les modules partagés (ex: `shared/hermes2022-extraction-files`) sont gérées via des chemins explicites relatifs à la racine du repository dans les fichiers de configuration
- [2025-10-20] Alternative évaluée : API JavaScript exposée par les modules partagés (rejetée pour complexité excessive)

#### Justification

- Simplicité de configuration (centralisée dans extraction-config.json)
- Ratio coût/bénéfice favorable pour notre contexte
- Pas de sur-engineering pour une flexibilité non nécessaire

#### Patterns validés

- **CHEMINS COMPLETS** : Utiliser chemins complets depuis repoRoot (ex: `hermes2022-concepts-site-extraction/config/nuextract-api-key.key`)
- **RÉSOLUTION** : Utiliser `find-up` + `path.resolve()` comme défini dans `@root-directory-governance.mdc`

#### Anti-Patterns à éviter

- **CHEMINS RELATIFS FRAGILES** : Éviter `../../../config/...` → **Solution** : Chemins depuis repoRoot → **Règle à adopter** : Utiliser `find-up` pour déterminer repoRoot
- **CHEMINS RELATIFS AU MODULE** : Éviter `config/nuextract-api-key.key` même dans le module → **Solution** : Toujours depuis repoRoot → **Règle à adopter** : `hermes2022-concepts-site-extraction/config/...`

#### État d'implémentation

🚧 [En cours d'implémentation]
